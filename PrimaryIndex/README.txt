Μελη Ομαδας:
1115201900052 ΜΑΡΙΑ ΔΙΑΜΑΝΤΗ
1115201900069 ΙΩΑΝΝΗΣ ΚΑΛΕΣΗΣ
1115201900157 ΝΙΚΟΛΑΟΣ ΠΝΕΥΜΑΤΙΚΟΣ

Κατα αρχας, θα εξηγησουμε οτι αφορα στην αποθηκευση/ενημερωση/ανακτηση της δομης επεκτατου κατακερματισμου στο αρχειο.
Οπως αναγραφεται στην εκφωνηση, στα πρωτα 4 bytes, κραταμε εναν int ο οποιος δηλωνει το global depth του επεκτατου κατακερματισμου.
Επειτα, στην 2η τετραδα απο bytes, δηλαδη στον δευτερο int του πρωτου block, κραταμε τον αριθμο μπλοκ τα οποια περιεχουν κομματια του επεκτατου κατακερματισμου.
Επειτα απο κει, θα ναι η αρχη ενος array απο integers το οποιο θα χει μηκος οσο ο αριθμος των hash block, και καθε θεση του θα περιεχει το block number καθε μπλοκ που περιεχει μεσα καποιο μερος του hash table.

Τα hash blocks αποτελουνται ενα array απο integers, οπου αν παρουμε με τη σειρα και συνδεσουμε ολους τους arrays απο ολα τα hash blocks θα προκυψει το hash table, οπου καθε int εχει το block number στο οποιο δειχνει.(Παραδοχη οτι ενα bucket περιεχει ενα block, αρα το block ειναι ο bucket)
Τα blocks που περιεχουν δεδομενα απο την αλλη, εχουν στην πρωτη θεση ενα int που μας λεει το local depth τους, και στα επομενα 4 bytes, εχουν εναν int που περιεχει τον αριθμο των εγγραφων στο block. Στο υπολοιπο μερος του block βαζουμε records, οπου και χωρανε συνολικα 8.

Το περιεχομενο του 1ου block το αρχικοποιουμε μια φορα στην HT_CreateIndex, και το ανανεωνουμε καθε φορα που κανουμε CloseFile.
Ομοια αντιμετωπιση εχουμε και στα hash blocks, οπου τα δημιουργουμε/ανανεωνουμε στην CloseFile.
Αυτο το κανουμε διοτι αφου αρχισει το προγραμμα, ειτε αν φτιαξει νεο hash table, ή διαβασει ετοιμο hash table απο το αρχειο, αυτο θα αποθηκευτει στην μνημη, και οτι αλλαγες γινουν στην δομη του, θα γινουν στο hash table που εχουμε στην μνημη. 
Με αυτο το τροπο ειναι πιο ευκολος ο χειρισμος του hash table.
Συγκεκριμενα, οταν κλεισουμε το αρχειο, θα παμε και θα βαλουμε το global depth μας στο global depth του 1ου block, και επειτα θα κοιταξουμε στο 1ο block για να δουμε ποσα hash blocks υπαρχουν ηδη στο αρχειο.
Συγκρινωντας το ποσα hash blocks εχουμε ηδη στο αρχειο με το ποσα hash blocks χρειαζομαστε για να φυλαξουμε τον πιθανοτατα αυξημενο array απο ints, θα δουμε εως ποιο σημειο πρεπει να γινει μια απλη ανανεωση των int που εχει το καθε hash block, και ποσα νεα hash block θα πρεπει να δημιουργηθουν.

Οσον αφορα τα block που περιεχουν δεδομενα, αυτα τα ενημερωνουμε με το που γινει οποιαδηποτε αλλαγη στο περιεχομενο τους, μιας και τα χρειαζομαστε να ναι ανανεωμενα καθολη τη διαρκεια της εκτελεσης.

Τωρα θα αναφερθουμε στο κομματι που αφορα τον επεκτατο κατακερματισμο γενικοτερα ως υλοποιηση.

Αρχικα, αξιζει να αναφερθει, οτι μια συναρτηση κατακερματισμου που κοιταει τα πρωτα bits θα μας εδινε το ιδιο hash value για τα δεδομενα, καθως 1111...01 ειναι ιδιο με 1111...00 για οσο κοιταμε κατι λιγοτερο απο τα 31 πρωτα bits. 
Οποτε καθως δεν εχουμε αλυσιδες υπερχειλισης αυτο θα μας εβαζε στην διαδικασια να γινουν συνεχεια overflows, και να χρειαστει να δεσμευτει πολυ μεγαλο μεγεθος μνημης, μονο για να βρουμε μια διαφορα μεταξυ 9 στοιχειων.
Για αυτο το λογο ακολουθησαμε την συμβουλη που μας δωθηκε στο eclass και καναμε αναστροφη των bit του αριθμου, ετσι ωστε τα λιγοτερα σημαντικα bit να ρθουν στην αρχη.
Με αυτον το τροπο, και παλι κοιταμε τα πρωτα bit του αριθμου, απλα τωρα τα πρωτα bit θα εχουν την απαραιτητα διαφορα ετσι ωστε να μας δωσουν διαφορετικο hash value.

Για το υπολοιπο μερος της υλοποιησης του επεκτατου κατακερματισμου, ιδιαιτερη εμφαση πρεπει να δωθει στην Insert, οπου καταλαμβανει και το περρισοτερο ζουμι της εργασιας,(εξαιρωντας την αποθηκευση/ανακτηση/ενημερωση των hash block)
Οσο χωραει ενα record στο block, το οποιο αναγνωριζεται απο το block number που περιεχει το hash table στην θεση που αντιστοιχει το hash value του record, τοτε απλα το βαζουμε στο block και ανανεωνουμε τις απαραιτητες πληροφοριες.

Αν δεν χωραει ομως το record στο block που θα πρεπε να μπει, ΚΑΙ το local depth του block αυτου ειναι ισο με το global depth, τοτε δημιουργουμε εναν πινακα διπλασσιου μεγεθους απο αυτον που χουμε, και αξιοποιωντας το γεγονος οτι καθε block(=bucket) θα πρεπει να το "δειχνουν" αριθμος θεσεων ισος με 2^(global_depth-local_depth),
βαζουμε σε καθε θεση του νεο array τα σωστα περιεχομενα.
Με αυτο το τροπο, καθε block να εχει διπλασσιο αριθμο θεσεων οπου το "δειχνουν", οπως λεει και η θεωρια.
Αφου δημιουργθει σωστα το νεο array και γινουν οσες αντιγραφες χρειαζονται απο το παλιο, αποδεσμευουμε την μνημη που δεσμευε το παλιο, και χρησιμοποιουμε τον νεο πινακα που φτιαξαμε για τον hash table μας, και εν τελη ξανακαλουμε την insert για να μπει το record σε block, οπου και θα καλεσθει η παρακατω περιπτωση.
(δεν χρειαζεται να κανουμε καποια αλλαγη στο αρχειο μιας και δεν πειραξαμε το περιεχομενο των data block, και οτι αλλαγη αφορα το περιεχομενο των hash blocks θα συμβει οταν κλεισουμε το αρχειο)

Στην περιπτωση τωρα, που δεν χωραει η εγγραφη στο block, αλλα το local depth του block ειναι μικροτερο του global depth, τοτε εμεις θα δημιουργησουμε ενα νεο block, και, οι μισες απο τις θεσεις που δειχναν στο αρχικο block, θα παραμεινουν να "δειχνουν" στο αρχικο block, ενω οι αλλες μισες, θα "δειχνουν" στο νεο block.
Εκτος αυτου, θετουμε τα local depth των δυο αυτων block, στο local depth του αρχικου +1, και τον αριθμο εγγραφων τους σε 0.
Τελος, εχωντας κρατησει τα records που χε το αρχικο block σε ενα array, τα ξανακανουμε ενα ενα insert στο hash table, με την ελπιδα καποια απο αυτα να πανε στο νεο block, και οταν τελειωσει αυτο, ξανακαλουμε την insert μας για να βαλει το record το οποιο εξαρχης θελαμε να βαλουμε(το οποιο επισης θα μπορουσε να παει στο νεο block) 



Ορθοτητα της Υλοποιηση:
Για να δειξουμε οτι δουλευει η υλοποιηση μας, εχουμε φτιαξει τρεις main, το σκοπο της καθε μιας θα αναλυσουμε
Η ht_main.c εχει στοχο να δειξει οτι δουλευει ο βασικος αλγοριθμος του επεκτατου πινακα κατακερματισμου, κανωντας insert 513 στοιχεια, το οποιο μας αναγκαζει να γινει oveflow εως και το global depth 7.
H ht_main2.c εχει στοχο να δειξει οτι δουλεψε η αποθηκευση των hash blocks που χαν γινει απο την ht_main.c, οπου και κανουμε insert αλλα 512 entries, τα οποια θα προκαλεσουν overflow σε global depth 8, και θα προκαλεσουν δημιουργια ενος παραπανω hash block στο αρχειο, το οποιο θα γινει εμφανες στον ελεγχο που ακολουθει. 
Η ht_main3.c εχει στοχο να δειξει οτι οντως στην προηγουμενη ht_main2.c εξαιτιας που φτασαμε σε global depth 8, αναγκαστηκαμε να φτιαξουμε 2 hash blocks, τα οποια και δουλευουν σωστα καθως και η ht_main3.c μπορει να τα κανει ανακτηση και να ξαναχτισει σωστα το σπασμενο hash table.
Επισης, η ht_main3.c δειχνει και οτι δουλευει η Hash Statistics ενω το αρχειο ειναι κλειστο, το οποιο ανοιγει για να το διαβασει και επειτα το κλεινει(αν χρειαστηκε να το ανοιξει).


Για να τρεξουμε αυτες τις main μεσω του makefile, κανουμε 

make ht_test_write_overflow_save      (κανει την ht_main)

make ht_test_read_write_overflow_save     (κανει την ht_main2)

make ht_test_read_save                   (κανει την ht_main3)

οπου και τρεχουμε καθε μια απο αυτες αφου τις κανουμε make μεσω του:

./build/runner

των οποιων τα ονοματα ειναι ενδεικτικα του τι κανουν.