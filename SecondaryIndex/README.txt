Μελη Ομαδας:
1115201900052 ΜΑΙΡΗ ΔΙΑΜΑΝΤΗ
1115201900069 ΙΩΑΝΝΗΣ ΚΑΛΕΣΗΣ
1115201900157 ΝΙΚΟΣ ΠΝΕΥΜΑΤΙΚΟΣ

Αξιζει να αναφερθει, οτι η δομη που χρησιμοποιειται για το Δευτερευων ευρετηριο ειναι παρομοια με αυτη του Πρωτευοντος που ειχαμε υλοποιησει.

Αρχικα για να χειριστουμε τα πολλα ανοικτα αρχεια, κραταμε στην μνημη το καθε hash table του καθενος ως πληροφορια στον πινακα ανοιχτων αρχειων, και με μια global variable κραταμε ποιο hash_table χρησιμοποιειται καθε φορα.
Με αυτον τον τροπο, αν παμε να κανουμε insert για το index2 ευρετηριο, αλλα στην μεταβλητη *hash_table εχουμε το hash table του index1, τοτε αλλαζουμε το περιεχομενο της μεταβλητης *hash_table με το σωστο πινακα κατακερματισμου.(by switching the pointer to show the other hash tables in memory)
Ο λογος που εχουμε τον πινακα στην μνημη ειναι για να ναι πιο απλος ο χειρισμος. 
Οι αλλαγες στα δεδομενα των blocks γινονται ακριβως την στιγμη που συμβαινουν, ενω οι αλλαγες στον πινακα κατακερματισμου αποθηκευονται σε μορφη block, καθε φορα που καλειται η Close.

Οσον αφορα τις διαφορες μεταξυ στην δομη Δευτερευωντος και Πρωτευοντος ευρετηριου, εμεις στο 1ο block του Δευτερευοντος κραταμε στα πρωτα 4 bytes το μεγεθος της λεξης κλειδιου, στα επομενα bytes βαζουμε το κλειδι στο οποιο βασιζεται το ευρετηριο, του οποιου το μεγεθος μας δινεται απο το attrLen, 
και επειτα στα επομενα 20 bytes αποθηκευουμε το ονομα του πρωτευοντος ευρετηριου στο οποιο "δειχνει" το δευτερευον ευρετηριο μας. Στα υπολοιπα bytes βαζουμε ιδιες πληροφοριες με αυτες που βαζαμε για το πρωτευων ευρετηριο(οπως global depth, αριθμο hash blocks, πινακα που μας λεει ποια blocks περιεχουν τμημα του hash_table)

Εκτος αυτων των αλλαγων, εχουμε αλλαξει και την συναρτηση HT_Insert ωστε να μας δινει το tupleId, και εναν πινακα με ενημερωσεις που πρεπει να γινουν στο δευτερευων ευρετηριο λογω καποιου split. 

Εδω αξιολογουμε οτι ποτε δεν θα γινει αριθμος ενημερωσεων πανω απο τον μεγιστο αριθμο records σε καποιο block του πρωτευοντος, πραγμα που γινεται εφικτο διοτι κοιταμε τα bit απο αριστερα προς τα δεξια.
Για αυτο και δημιουργουμε εναν πινακα updateArray ο οποιος εχει 8 θεσεις τον οποιο και περναμε στην συναρτηση. 

Καθως καλουμε την HT_Insert αναδρομικα, χρειαζομαστε καποιο τροπο να ξερουμε ποτε ο πινακας αυτος εχει ηδη τιμες απο προηγουμενη αναδρομη, ή ποτε ειναι η πρωτη φορα που το βαζουμε στην κληση της συναρτησης, για αυτο αφηνουμε στον χρηση την ευθυνη να αρχικοποιησει τον πινακα με updateArray[0].size=-1 ετσι ωστε να ξερουμε πληροφοριες για τον πινακα και να μην υπαρξει καποιο θεμα με uninitialised values.
Επειτα,στην split, για καθε record που κανουμε insert, αποθηκευουμε το νεο tupleId που ελαβε απο την Insert και το βαζουμε στον πινακα ενημερωσεων στην θεση που αντιστοιχει στο id του record αυτου.   

Οσον αφορα την SHT_Update, περναμε τον πινακα 8 θεσεων, και κοιταμε καθε θεση του (σε περιπτωση που εχει μεγεθος διαφορο του -1), για να δουμε αν οντως υπηρξε αλλαγη. 
Αν το oldTupleId ειναι διαφορο του newTupleId, τοτε πηγαινουμε στο στοιχειο που αντιστοιχει στο σωστο city ή surname (αναλογα το κλειδι του ευρετηριου μας) και βρισκουμε απο ολες τις εγγραμες με το ιδιο κλειδι, αυτην που εχει το σωστο oldTupleId, και κανουμε την αλλαγη.

Ενα ιδιατερο σημειο ειναι οτι εμεις πρωτα καλουμε την SHT_Update και μετα την SHT_Insert καθως μπορει ενα secondary record να πρεπει να αλλαξει απο tupleId 4 σε 5, ετσι ωστε το νεο record να παρει την τιμη 4. 
Οπου το να αφηναμε να υπαρχουν για καποια στιγμη δυο διαφορετικα secondary records που να δειχνουν στο ιδιο primary record θα μπορουσε να αφησει χωρο για undefined behavior.(στην περιπτωση μας δεν θα συνεβαινε αυτο, διοτι αν εχουμε τα δυο secondary records ["Αθηνα",4] και ["Αθηνα",4] τοτε δεν μας νοιαζει ποιο απο τα δυο θα μετρεψουμε σε ["Αθηνα",5])

Για να εκτυπωσουμε τις εγγραφες του πρωτευοντος που αντιστοιχουν στο index_key, εμεις παμε και βρισκουμε το block που μας δειχνει σε ποιες θεσεις του πρωτευον πρεπει να κοιταξουμε, και επειτα φορτωνουμε τα αντιστοιχα blocks που αντιστοιχουν στο πρωτευον μεσω αντοιστιχισης του filename και blockFile_indexDesc.

Μιας και ο πινακας ανοιχτων αρχειων παρεχει χρησιμες πληροφοριες για το πρωτευων που χρειαζεται να ξερει και το δευτερευων, κανουμε extern τον πινακα openfiles απο το hash_file.c και δουλευουμε με εναν κοινο πινακα(απο τον οποιο μπορουμε να βρουμε το blockFile_indexDesc χρησιμοποιωντας μονο το filename ενος αρχειου).

Για την υλοποίηση της inner join, υλοποιήσαμε μια εξτρά βοηθητική συνάρτηση, την rec_arr. 
Η συνάρτηση αυτή προσθέτει σε έναν πίνακα με τύπου εγγραφών, όλες τις εγγραφές από ένα αρχείο,που έχουν κλειδί
το κλειδί που δόθηκε όρισμα στη join. Επομένος στην join Καλούμε δυο φορές την συνάρτη rec_arr για κάθε αρχείο που δόθηκε και δημιουργούμαι 
δύο πίνακες που περιέχουν τις εγγραφές με κλειδί ίδιο με αυτό που δόθηκε. διατρέχουμε τους δυο πίνακες και εκτυπώνουμε τα στοιχεία 
όπως με ειπώθηκε στην παράδωση της εργασίας.
Αν για κλειδί δωθεί NULL τότε διατρέχουμε όλο το δευτερεύον ευρετήριο του πρώτου αρχείου και για κάθε στοιχείο από κάθε block καλούμαι 
αναδρομικά την join.

Στη main δημιουργούμε δύο πρωτεύοντα ευρετήρια και δύο δευτερεύοντα που αντιστιχούν στα πρωτεύον και καλούμε την join για να πάρουμε όλες τις ζεύξεις, οπου και για να δειξουμε οτι ειναι σωστες οι εκτυπωσεις(μαις και δεν φαινεται αμεσα απο τον τροπο εκτπυωσης που εχει ζητηθει, εχουμε βαλει δυο assert οι οποιες συγκρινουν αν αυτα που παμε να εκτυπωσουμε εχουν οντως το σωστο επιθετο)

make ht  (shows that HT works, althought that has already been shown in previous project)

make sht (shows functionality of secondary hash tables, by having one for city and one for surname for same primary hash table and printing as we insert and after we close/reopen the files)

make inner (shows that inner join finds and prints correctly)

to run each of the tests, run:

./build/runner